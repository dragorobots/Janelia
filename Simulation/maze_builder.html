<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Maze Builder (Units-First + Minimal Schematic + Delete Mode)</title>
<style>
  :root{
    --bg:#0f151a; --panel:#151e26; --ink:#e8eef4; --ink-dim:#a7b3bf;
    --grid:#24303a; --grid-bold:#324555; --shadow:0 10px 24px rgba(0,0,0,.35);
    --radius:16px; --danger:#ff6b6b; --accent:#5dd0ff;
  }
  html,body{height:100%}
  body{margin:0; font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,"Helvetica Neue",Arial; background:var(--bg); color:var(--ink);
       display:grid; grid-template-rows:auto 1fr}
  header{display:flex; gap:12px; align-items:center; flex-wrap:wrap; padding:10px 14px; background:var(--panel); box-shadow:var(--shadow); position:sticky; top:0; z-index:5}
  header h1{font-size:16px; margin:0 10px 0 0}
  .controls{display:flex; gap:12px; flex-wrap:wrap; align-items:end}
  .group{background:#10171d; border:1px solid #1f2a35; border-radius:12px; padding:10px 12px; min-width:260px}
  .row{display:flex; gap:10px; align-items:center; margin:6px 0}
  label{font-size:12px; color:var(--ink-dim)}
  input[type="number"], select{background:#0c1217; color:var(--ink); border:1px solid #26323e; border-radius:10px; padding:7px 9px; outline:none; width:100%}
  .btn{background:linear-gradient(180deg,#1d2a35,#17222b); color:var(--ink); border:1px solid #2a3946; border-radius:12px; padding:9px 12px; cursor:pointer}
  .btn.primary{background:linear-gradient(180deg,#234155,#163145); border-color:#2b4459}
  .btn.warn{background:linear-gradient(180deg,#3b2225,#2a181a); border-color:#513033}
  .btn.toggle-active{box-shadow:0 0 0 2px rgba(255,90,90,.25) inset; border-color:#7e3d41}
  .muted{color:var(--ink-dim); font-size:12px}
  .pill{padding:2px 8px; border-radius:999px; border:1px solid #2a3946; color:#a8d4f2; font-size:12px}
  #stage{position:relative; margin:14px; border-radius:var(--radius); box-shadow:var(--shadow); background:#0b1116; height:calc(100vh - 170px); overflow:auto}
  /* JS sets exact CSS width/height on the canvas to prevent any stretch */
  #canvas{display:block; background:#0b1116; cursor:crosshair; image-rendering:pixelated}
  #readout{position:absolute; left:10px; bottom:10px; padding:6px 10px; background:rgba(0,0,0,.45); border:1px solid rgba(255,255,255,.08);
           border-radius:10px; font:12px/1.4 ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono"; color:var(--ink-dim)}
  #toast{position:fixed; right:14px; bottom:14px; background:#0f171d; border:1px solid #253241; color:#d5e4f1; padding:10px 12px; border-radius:12px; box-shadow:var(--shadow); opacity:0; transform:translateY(8px); transition:.25s}
  #toast.show{opacity:1; transform:translateY(0)}
  dialog{border:none; border-radius:16px; background:#0f171d; color:var(--ink); padding:0; width:min(1000px,92vw)}
  dialog::backdrop{background:rgba(0,0,0,.55)}
  .modal-head{display:flex; align-items:center; justify-content:space-between; padding:12px 14px; border-bottom:1px solid #233241}
  .modal-body{padding:12px 14px}
  pre{background:#0b1116; border:1px solid #26323e; color:#cfe6ff; padding:12px; border-radius:12px; max-height:55vh; overflow:auto; font-size:12.5px}
  .schem-wrap{background:#fff; padding:8px; border-radius:12px; overflow:auto; max-height:62vh}
</style>
</head>
<body>
  <header>
    <h1>Maze Builder</h1>
    <div class="controls">
      <div class="group">
        <label>Units & Grid (no pixels)</label>
        <div class="row">
          <div style="flex:1">
            <label>Unit system</label>
            <select id="unitName">
              <option value="mm">millimeters (mm)</option>
              <option value="cm" selected>centimeters (cm)</option>
              <option value="in">inches (in)</option>
              <option value="ft">feet (ft)</option>
              <option value="m">meters (m)</option>
            </select>
          </div>
        </div>
        <div class="row">
          <div style="flex:1">
            <label>1 grid unit equals</label>
            <div class="row" style="gap:6px">
              <input id="physPerUnit" type="number" min="0.001" step="0.001" value="10" style="width:120px">
              <span class="pill" id="physPerUnitLabel">cm</span>
            </div>
          </div>
        </div>
        <div class="row" style="gap:12px">
          <div style="flex:1">
            <label>Columns (grid units)</label>
            <input id="cols" type="number" min="1" max="400" step="1" value="40">
          </div>
          <div style="flex:1">
            <label>Rows (grid units)</label>
            <input id="rows" type="number" min="1" max="400" step="1" value="28">
          </div>
        </div>
        <div class="row">
          <div style="flex:1">
            <label>Minimum wall length</label>
            <div class="row" style="gap:6px">
              <input id="minWallPhys" type="number" min="0" step="0.01" value="20" style="width:120px">
              <span class="pill" id="minWallPhysLabel">cm</span>
            </div>
            <div class="muted">= at least <b><span id="minUnitsOut">2</span> unit(s)</b></div>
          </div>
        </div>
        <div class="row">
          <label class="muted"><input id="showGridIdx" type="checkbox" checked> Show grid index (editor only)</label>
        </div>
      </div>

      <div class="group">
        <label>Wall Style</label>
        <div class="row">
          <div style="flex:1">
            <label>Wall width (grid units)</label>
            <input id="wallUnits" type="number" min="0.05" step="0.05" value="0.3">
            <div class="muted">≈ <span id="wallWidthPhys">3</span> <span id="wallWidthUnitLabel">cm</span></div>
          </div>
        </div>
        <div class="row">
          <label class="muted"><input id="axisLock" type="checkbox" checked> Orthogonal only</label>
        </div>
      </div>

      <div class="group" style="display:flex; gap:8px; align-items:center">
        <button id="undoBtn" class="btn">Undo</button>
        <button id="clearBtn" class="btn warn">Clear</button>
        <button id="deleteModeBtn" class="btn warn">Delete Walls</button>
        <button id="exportBtn" class="btn">Export Data (JSON)</button>
        <button id="schemBtn" class="btn primary">Schematic</button>
      </div>
    </div>
  </header>

  <div id="stage">
    <canvas id="canvas"></canvas>
    <div id="readout">Ready. Click-drag to draw. Release to place. Right-click to cancel.</div>
  </div>

  <!-- JSON export -->
  <dialog id="exportDlg">
    <div class="modal-head">
      <strong>Exported Maze Data</strong>
      <div class="stack">
        <button id="copyBtn" class="btn">Copy JSON</button>
        <button id="downloadBtn" class="btn primary">Download JSON</button>
        <button id="closeExport" class="btn">Close</button>
      </div>
    </div>
    <div class="modal-body">
      <div class="muted" style="margin-bottom:8px">
        Coordinates are integer <b>grid units</b> (origin = top-left) and converted to your selected physical units.
      </div>
      <pre id="exportOut"></pre>
    </div>
  </dialog>

  <!-- Schematic export -->
  <dialog id="schemDlg">
    <div class="modal-head">
      <strong>Maze Schematic</strong>
      <div class="stack">
        <button id="schemDownloadSVG" class="btn">Download SVG</button>
        <button id="schemDownloadPNG" class="btn">Download PNG</button>
        <button id="closeSchem" class="btn">Close</button>
      </div>
    </div>
    <div class="modal-body">
      <div class="muted" style="margin-bottom:8px">
        Shows the grid and maze only. All notes are in the bottom info box—no text on the grid itself.
      </div>
      <div id="schemWrap" class="schem-wrap"></div>
    </div>
  </dialog>

  <div id="toast"></div>

<script>
'use strict';
(function(){
  // DOM
  const stage = document.getElementById('stage');
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');

  // Inputs
  const unitNameSel = document.getElementById('unitName');
  const physPerUnitInput = document.getElementById('physPerUnit');
  const physPerUnitLabel = document.getElementById('physPerUnitLabel');
  const minWallPhysInput = document.getElementById('minWallPhys');
  const minWallPhysLabel = document.getElementById('minWallPhysLabel');
  const minUnitsOut = document.getElementById('minUnitsOut');
  const colsInput = document.getElementById('cols');
  const rowsInput = document.getElementById('rows');
  const wallUnitsInput = document.getElementById('wallUnits');
  const wallWidthPhys = document.getElementById('wallWidthPhys');
  const wallWidthUnitLabel = document.getElementById('wallWidthUnitLabel');
  const showGridIdx = document.getElementById('showGridIdx');
  const axisLockChk = document.getElementById('axisLock');

  // Buttons & dialogs
  const undoBtn = document.getElementById('undoBtn');
  const clearBtn = document.getElementById('clearBtn');
  const deleteModeBtn = document.getElementById('deleteModeBtn');
  const exportBtn = document.getElementById('exportBtn');
  const schemBtn = document.getElementById('schemBtn');

  const exportDlg = document.getElementById('exportDlg');
  const exportOut = document.getElementById('exportOut');
  const copyBtn = document.getElementById('copyBtn');
  const downloadBtn = document.getElementById('downloadBtn');

  const schemDlg = document.getElementById('schemDlg');
  const schemWrap = document.getElementById('schemWrap');
  const schemDownloadSVG = document.getElementById('schemDownloadSVG');
  const schemDownloadPNG = document.getElementById('schemDownloadPNG');

  const readout = document.getElementById('readout');
  const toastEl = document.getElementById('toast');

  // State
  let cols = +colsInput.value, rows = +rowsInput.value;
  let unitName = unitNameSel.value;
  let physPerUnit = +physPerUnitInput.value;
  let minWallPhys = +minWallPhysInput.value;
  let minUnits = Math.max(1, Math.ceil(minWallPhys / physPerUnit));
  let wallWidthUnits = +wallUnitsInput.value;

  let cellSize = 28;            // computed to fit stage; not shown in UI
  let dpr = window.devicePixelRatio || 1;
  let deleteMode = false;

  // custom red crosshair cursor for delete mode
  const redCursor = "url(\"data:image/svg+xml;utf8," +
    "<svg xmlns='http://www.w3.org/2000/svg' width='32' height='32' viewBox='0 0 32 32'>" +
    "<rect width='32' height='32' fill='none'/>" +
    "<path d='M16 4v24M4 16h24' stroke='red' stroke-width='2'/>" +
    "<circle cx='16' cy='16' r='4' fill='none' stroke='red' stroke-width='2'/>" +
    "</svg>\") 16 16, crosshair";

  /** segments in integer grid units */
  /** @type {{x1:number,y1:number,x2:number,y2:number}[]} */
  let segments = [];

  // Interaction
  let isDrawing = false, start = null, hover = null, cancelOnUp = false;

  // Helpers
  const clamp = (v,min,max)=>Math.max(min, Math.min(max, v));
  const showToast = (m)=>{ toastEl.textContent = m; toastEl.classList.add('show'); setTimeout(()=>toastEl.classList.remove('show'), 1500); };
  const setReadout = (m)=>{ readout.textContent = m; };
  const fmt = (v)=>{ const n = Math.round(v*10000)/10000; return (''+n).replace(/\\.0+$/,''); };

  function updateMinUnits(){
    minUnits = Math.max(1, Math.ceil(minWallPhys / physPerUnit));
    minUnitsOut.textContent = String(minUnits);
    wallWidthPhys.textContent = fmt(wallWidthUnits * physPerUnit);
    wallWidthUnitLabel.textContent = unitName;
  }

  function gridW(){ return cols * cellSize; }
  function gridH(){ return rows * cellSize; }

  function computeCellSize(){
    const availW = Math.max(100, stage.clientWidth - 8);
    const availH = Math.max(100, stage.clientHeight - 8);
    const byW = Math.floor(availW / Math.max(1, cols));
    const byH = Math.floor(availH / Math.max(1, rows));
    cellSize = clamp(Math.min(byW, byH), 8, 80);
  }

  function applyCanvasSizing(){
    computeCellSize();
    const cssW = gridW();
    const cssH = gridH();
    canvas.style.width = cssW + 'px';
    canvas.style.height = cssH + 'px';
    dpr = window.devicePixelRatio || 1;
    canvas.width  = Math.max(1, Math.round(cssW * dpr));
    canvas.height = Math.max(1, Math.round(cssH * dpr));
    ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS px
  }

  function drawGrid(){
    ctx.clearRect(0,0,gridW(),gridH());
    ctx.lineWidth = 1;
    ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--grid');
    ctx.beginPath();
    for (let x=0; x<=cols; x++){ const X = x*cellSize + 0.5; ctx.moveTo(X,0); ctx.lineTo(X,gridH()); }
    for (let y=0; y<=rows; y++){ const Y = y*cellSize + 0.5; ctx.moveTo(0,Y); ctx.lineTo(gridW(),Y); }
    ctx.stroke();

    ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--grid-bold');
    ctx.beginPath();
    for (let x=0; x<=cols; x+=5){ const X = x*cellSize + 0.5; ctx.moveTo(X,0); ctx.lineTo(X,gridH()); }
    for (let y=0; y<=rows; y+=5){ const Y = y*cellSize + 0.5; ctx.moveTo(0,Y); ctx.lineTo(gridW(),Y); }
    ctx.stroke();

    if (showGridIdx.checked){
      ctx.fillStyle = 'rgba(255,255,255,.45)';
      ctx.font = '10px ui-monospace, monospace';
      ctx.textAlign='left'; ctx.textBaseline='top';
      for (let x=0; x<=cols; x+=5){ ctx.fillText(String(x), x*cellSize+2, 2); }
      for (let y=0; y<=rows; y+=5){ ctx.fillText(String(y), 2, y*cellSize+2); }
    }
  }

  function drawSegments(){
    const widthPx = Math.max(1, wallWidthUnits * cellSize);
    ctx.lineCap='square'; ctx.lineJoin='miter'; ctx.strokeStyle='#9bd8ff'; ctx.lineWidth=widthPx;
    ctx.beginPath();
    for (const s of segments){ ctx.moveTo(s.x1*cellSize, s.y1*cellSize); ctx.lineTo(s.x2*cellSize, s.y2*cellSize); }
    ctx.stroke();
  }

  function drawPreview(){
    if (!isDrawing || !start || !hover || deleteMode) return;
    const end = snapAxis(start, hover);
    const lenUnits = Math.max(Math.abs(end.x-start.x), Math.abs(end.y-start.y));
    const ok = lenUnits >= minUnits;

    ctx.save();
    ctx.lineCap='square'; ctx.setLineDash([8,6]);
    ctx.strokeStyle = ok ? '#7cffb6' : '#ff8b8b';
    ctx.lineWidth = Math.max(1, wallWidthUnits * cellSize);
    ctx.beginPath(); ctx.moveTo(start.x*cellSize, start.y*cellSize); ctx.lineTo(end.x*cellSize, end.y*cellSize); ctx.stroke();
    ctx.restore();

    setReadout(`preview: (${start.x},${start.y}) → (${end.x},${end.y}) | ${lenUnits} unit${lenUnits!==1?'s':''} ${ok?'':'(too short)'}`);
  }

  function draw(){ drawGrid(); drawSegments(); drawPreview(); }

  function snapAxis(p0,p1){
    if (!axisLockChk.checked) return p1;
    const dx=Math.abs(p1.x-p0.x), dy=Math.abs(p1.y-p0.y);
    return (dx>=dy)? {x:p1.x,y:p0.y} : {x:p0.x,y:p1.y};
  }

  function segKey(s){ const {x1,y1,x2,y2}=s; return (x1<x2 || (x1===x2 && y1<=y2))?`${x1},${y1}→${x2},${y2}`:`${x2},${y2}→${x1},${y1}`; }
  function addSegment(s){
    if (s.x1===s.x2 && s.y1===s.y2) return false;
    const lenUnits = Math.max(Math.abs(s.x2-s.x1), Math.abs(s.y2-s.y1));
    if (lenUnits < minUnits){ showToast(`Wall too short (≥ ${minUnits} units).`); return false; }
    const k = segKey(s); for (const t of segments){ if (segKey(t)===k){ showToast('Wall already exists.'); return false; } }
    segments.push(s); return true;
  }

  // --- Deletion helpers ---
  function pointToSegDistanceUnits(p, s){
    // Euclidean distance from point p to segment s in grid units
    const x=p.x, y=p.y, x1=s.x1, y1=s.y1, x2=s.x2, y2=s.y2;
    const dx=x2-x1, dy=y2-y1;
    const len2=dx*dx+dy*dy;
    let t=0;
    if (len2>0) t=((x-x1)*dx+(y-y1)*dy)/len2;
    t=Math.max(0,Math.min(1,t));
    const nx=x1+t*dx, ny=y1+t*dy;
    return Math.hypot(x-nx,y-ny);
  }
  function deleteSegmentAtPoint(p){
    if (!segments.length) return false;
    const hitThresh = Math.max(0.35, wallWidthUnits/2 + 0.15); // in grid units
    let best=-1, bestDist=1e9;
    for (let i=0;i<segments.length;i++){
      const d = pointToSegDistanceUnits(p, segments[i]);
      if (d < bestDist){ bestDist=d; best=i; }
    }
    if (best>=0 && bestDist<=hitThresh){
      const s = segments.splice(best,1)[0];
      showToast(`Deleted wall: (${s.x1},${s.y1}) → (${s.x2},${s.y2})`);
      refreshExportIfOpen();
      return true;
    }
    showToast('No wall at click point.');
    return false;
  }

  // Pointer → unit mapping (exact; canvas is not stretched)
  function mouseToUnit(e){
    const r = canvas.getBoundingClientRect();
    const x = e.clientX - r.left;
    const y = e.clientY - r.top;
    const u = clamp(Math.round(x / cellSize), 0, cols);
    const v = clamp(Math.round(y / cellSize), 0, rows);
    return {x:u, y:v};
  }

  // JSON export
  function buildExportText(){
    const scale = physPerUnit;
    const enriched = segments.map(s=>{
      const lenUnits = Math.max(Math.abs(s.x2-s.x1), Math.abs(s.y2-s.y1));
      const orientation = (s.y1===s.y2)?'H':(s.x1===s.x2)?'V':'other';
      return {
        start_units:[s.x1,s.y1], end_units:[s.x2,s.y2], length_units:lenUnits,
        start_physical:[s.x1*scale,s.y1*scale], end_physical:[s.x2*scale,s.y2*scale],
        length_physical:lenUnits*scale, orientation
      };
    });
    const payload = {
      meta:{
        origin:"top-left",
        grid_units:{cols,rows},
        unit_name:unitName,
        physical_per_grid_unit:scale,
        min_wall_length_units:minUnits,
        wall_width_units:wallWidthUnits,
        overall_size_physical:{width:cols*scale, height:rows*scale}
      },
      segments:enriched
    };
    return JSON.stringify(payload,null,2);
  }
  function refreshExportIfOpen(){
    if (exportDlg.open){
      exportOut.textContent = buildExportText();
    }
  }
  function exportJSON(){
    const text = buildExportText();
    exportOut.textContent = text;
    const now=new Date(), pad=n=>String(n).padStart(2,'0');
    const stamp=`${now.getFullYear()}${pad(now.getMonth()+1)}${pad(now.getDate())}_${pad(now.getHours())}${pad(now.getMinutes())}${pad(now.getSeconds())}`;
    downloadBtn.onclick=()=>{ const blob=new Blob([text],{type:'application/json'}); const url=URL.createObjectURL(blob);
      const a=document.createElement('a'); a.href=url; a.download=`maze_export_${stamp}.json`; a.click(); URL.revokeObjectURL(url); };
    copyBtn.onclick=async()=>{ try{ await navigator.clipboard.writeText(text);}catch{} };
    exportDlg.showModal();
  }

  // -------- Minimal Schematic (grid + maze + bottom info box) --------
 // Schematic (grid + maze + bottom info box)
// ONLY CHANGE: smaller text via SCHEM_FONT_PX
function makeSchematicSVG(){
  const scale  = physPerUnit;
  const infoH  = 5;      // bottom info box height in grid units
  const margin = 1.5;    // outer margin (grid units)
  const vbW = cols + margin*2;
  const vbH = rows + infoH + margin*2;

  // ↓ Adjust this one number if you want the text larger/smaller
  const SCHEM_FONT_PX = .5;   // was 12px before

  // Grid (no text placed on grid)
  let grid = '';
  for (let x=0; x<=cols; x++)   grid += `<line x1='${x}' y1='0' x2='${x}' y2='${rows}' class='grid'/>`;
  for (let y=0; y<=rows; y++)   grid += `<line x1='0' y1='${y}' x2='${cols}' y2='${y}' class='grid'/>`;
  for (let x=0; x<=cols; x+=5)  grid += `<line x1='${x}' y1='0' x2='${x}' y2='${rows}' class='grid5'/>`;
  for (let y=0; y<=rows; y+=5)  grid += `<line x1='0' y1='${y}' x2='${cols}' y2='${y}' class='grid5'/>`;

  // Maze walls
  let walls=''; 
  for (const s of segments) walls += `<line x1='${s.x1}' y1='${s.y1}' x2='${s.x2}' y2='${s.y2}' class='wall'/>`;

  // Bottom info box (all annotation goes here only)
  const wPhys  = (Math.round(cols*scale*10000)/10000).toString();
  const hPhys  = (Math.round(rows*scale*10000)/10000).toString();
  const wallPhys = (Math.round(wallWidthUnits*scale*10000)/10000).toString();
  const stamp = new Date().toISOString().replace('T',' ').replace(/\..+/,'');

  const info = `
    <g transform='translate(0, ${rows + 0.5})'>
      <rect x='0' y='0' width='${cols}' height='${infoH-1}' class='ibox'/>
      <g transform='translate(0.8, 0.9)'>
        <text class='itext'>
          <tspan x='0' dy='0'>Units: ${unitName}</tspan>
          <tspan x='0' dy='1.1em'>1 grid unit = ${scale} ${unitName}</tspan>
          <tspan x='0' dy='1.1em'>Grid size: ${cols} × ${rows} units</tspan>
          <tspan x='0' dy='1.1em'>Overall size: ${wPhys} × ${hPhys} ${unitName}</tspan>
        </text>
      </g>
      <g transform='translate(${cols/2+0.8}, 0.9)'>
        <text class='itext'>
          <tspan x='0' dy='0'>Wall width: ${wallWidthUnits} units (${wallPhys} ${unitName})</tspan>
          <tspan x='0' dy='1.1em'>Min wall length: ≥ ${minUnits} units</tspan>
          <tspan x='0' dy='1.1em'>Walls: ${segments.length}</tspan>
          <tspan x='0' dy='1.1em'>Generated: ${stamp}</tspan>
        </text>
      </g>
    </g>`;

  // Pixel size for raster export (unchanged behavior)
  const ppu = Math.max(10, Math.min(40, Math.floor(1200 / Math.max(cols, rows+infoH))));
  const pxW = Math.round(vbW * ppu);
  const pxH = Math.round(vbH * ppu);

  return `
<svg xmlns='http://www.w3.org/2000/svg' width='${pxW}' height='${pxH}'
     viewBox='${-margin} ${-margin} ${vbW} ${vbH}'>
  <defs>
    <style>
      .grid  { stroke:#d8dde3; stroke-width:0.2; vector-effect:non-scaling-stroke; }
      .grid5 { stroke:#b7c1cc; stroke-width:0.4; vector-effect:non-scaling-stroke; }
      .wall  { stroke:#000; stroke-width:${wallWidthUnits*10}; stroke-linecap:square; vector-effect:non-scaling-stroke; }
      .ibox  { fill:#f7fafc; stroke:#c7d3df; stroke-width:0.6; }
      /* ↓ only the font size changed */
      .itext { font-family: Arial, Helvetica, sans-serif; font-size:${SCHEM_FONT_PX}px; fill:#111; text-rendering:geometricPrecision; }
    </style>
  </defs>
  <g>${grid}</g>
  <g>${walls}</g>
  ${info}
</svg>`;
}

  function openSchematic(){
    const svg = makeSchematicSVG();
    schemWrap.innerHTML = svg;
    schemDlg.showModal();

    // Fresh bindings with current SVG text
    schemDownloadSVG.onclick = ()=>{
      const blob = new Blob([svg], {type:'image/svg+xml'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = 'maze_schematic.svg'; a.click();
      URL.revokeObjectURL(url);
    };
    schemDownloadPNG.onclick = ()=>{
      const img = new Image();
      img.onload = ()=>{
        const c = document.createElement('canvas');
        c.width = img.naturalWidth || img.width;
        c.height = img.naturalHeight || img.height;
        const g = c.getContext('2d');
        g.fillStyle = '#ffffff'; g.fillRect(0,0,c.width,c.height);
        g.drawImage(img, 0, 0);
        const a = document.createElement('a');
        a.href = c.toDataURL('image/png');
        a.download = 'maze_schematic.png';
        a.click();
      };
      img.src = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(svg);
    };
  }
  // -------------------------------------------------------------------

  // Events
  function startDraw(e){
    if (e.button===2){ isDrawing=false; start=null; hover=null; draw(); return; }
    if (deleteMode){
      const p = mouseToUnit(e);
      deleteSegmentAtPoint(p);
      draw();
      return;
    }
    const p=mouseToUnit(e); start=p; hover=p; isDrawing=true; cancelOnUp=false; setReadout(`start: (${p.x},${p.y})`); draw();
  }
  function moveDraw(e){ const p=mouseToUnit(e); hover=p; if(!isDrawing){ setReadout(`cursor: (${p.x},${p.y})`); draw(); return;} draw(); }
  function endDraw(e){
    if (!isDrawing || deleteMode) return;
    if (cancelOnUp){ isDrawing=false; start=null; hover=null; draw(); return; }
    const P0=start, P1 = snapAxis(P0, mouseToUnit(e)); const seg={x1:P0.x,y1:P0.y,x2:P1.x,y2:P1.y};
    if(addSegment(seg)){ const len=Math.max(Math.abs(seg.x2-seg.x1),Math.abs(seg.y2-seg.y1)); setReadout(`placed: (${seg.x1},${seg.y1}) → (${seg.x2},${seg.y2}) length ${len}`); }
    isDrawing=false; start=null; hover=null; draw();
  }
  function cancelDraw(e){ e.preventDefault(); if(isDrawing){ cancelOnUp=true; showToast('Drawing canceled.'); } }

  // Wiring
  function applyUnitsUI(){
    unitName = unitNameSel.value;
    physPerUnitLabel.textContent = unitName;
    minWallPhysLabel.textContent = unitName;
    wallWidthUnitLabel.textContent = unitName;
    updateMinUnits(); draw();
  }
  unitNameSel.addEventListener('change', applyUnitsUI);
  physPerUnitInput.addEventListener('change', ()=>{ physPerUnit=Math.max(0.000001,+physPerUnitInput.value||1); updateMinUnits(); draw(); refreshExportIfOpen(); });
  minWallPhysInput.addEventListener('change', ()=>{ minWallPhys=Math.max(0,+minWallPhysInput.value||0); updateMinUnits(); draw(); refreshExportIfOpen(); });
  wallUnitsInput.addEventListener('change', ()=>{ wallWidthUnits=Math.max(0.05,+wallUnitsInput.value||0.05); updateMinUnits(); draw(); refreshExportIfOpen(); });
  colsInput.addEventListener('change', ()=>{ cols=clamp(Math.round(+colsInput.value),1,400); colsInput.value=cols; applyCanvasSizing(); draw(); refreshExportIfOpen(); });
  rowsInput.addEventListener('change', ()=>{ rows=clamp(Math.round(+rowsInput.value),1,400); rowsInput.value=rows; applyCanvasSizing(); draw(); refreshExportIfOpen(); });
  showGridIdx.addEventListener('change', draw);
  axisLockChk.addEventListener('change', draw);

  // Toggle delete mode
  deleteModeBtn.addEventListener('click', ()=>{
    deleteMode = !deleteMode;
    deleteModeBtn.classList.toggle('toggle-active', deleteMode);
    deleteModeBtn.textContent = deleteMode ? 'Delete Walls (ON)' : 'Delete Walls';
    canvas.style.cursor = deleteMode ? redCursor : 'crosshair';
    setReadout(deleteMode ? 'Delete mode: click a wall to remove it' : 'Draw mode: click-drag to add walls');
  });

  undoBtn.addEventListener('click', ()=>{ if(segments.length){ segments.pop(); draw(); refreshExportIfOpen(); }});
  clearBtn.addEventListener('click', ()=>{ if(!segments.length) return; if(confirm('Clear all walls?')){ segments.length=0; draw(); refreshExportIfOpen(); }});
  exportBtn.addEventListener('click', exportJSON);
  schemBtn.addEventListener('click', openSchematic);
  document.getElementById('closeExport').addEventListener('click', ()=>exportDlg.close());
  document.getElementById('closeSchem').addEventListener('click', ()=>schemDlg.close());

  canvas.addEventListener('mousedown', startDraw);
  window.addEventListener('mousemove', moveDraw);
  window.addEventListener('mouseup', endDraw);
  canvas.addEventListener('contextmenu', cancelDraw);
  window.addEventListener('resize', ()=>{ applyCanvasSizing(); draw(); });

  // Init
  applyUnitsUI();
  applyCanvasSizing();
  draw();
})();
</script>
</body>
</html>
